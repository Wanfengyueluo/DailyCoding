# 2020.3.13

## 169.多数元素

:black_nib:解题思路：

1. 哈希
2. 排序法，次数大于n/2的元素必定出现在排序后nums[n/2]的位置上
3. Boyer-Moore投票算法，将众数记为+1，其他数记为-1，设置计数器count和candidate，当count=0时，令candidate = num。当candidate==num时，count+1，否则count-1

```java
class Solution {
	private int majorityElement(int[] nums){
		int count = 0;
		int candidate = 0;
		for (int num:nums){
			if(count==0){
				candidate = num;
			}
			count = count + (candidate==num?1:-1);
		}
		return candidate;
	}
}
```

## 70.爬楼梯

:black_nib:解题思路：

1. DP打表
2. 斐波那契数

```java
//法一
class Solution {
	public int climbStairs(int n) {
		if (n == 1) {
			return 1;
		}
		int[] dp = new int[n + 1];
		dp[1] = 1;
		dp[2] = 2;
		for (int i = 3; i <= n; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[n];
	}
}
//法二
class Solution {
	public int climbStairs(int n) {
		if (n == 1) {
			return 1;
		}
		int first = 1;
		int second = 2;
		for (int i = 3; i <= n; i++) {
			second = first + second;
			first = second - first;
		}
		return second;
	}
}
```

## 198.打家劫舍

:black_nib:解题思路：

1. DP打表
   $$
   dp[i] = max(dp[i-2]+nums[i],dp[i-1])
   $$
   

```java
class Solution {
	public int rob(int[] nums) {
        if (nums.length == 0) {
			return 0;
		}
		if (nums.length == 1) {
			return nums[0];
		}
		if (nums.length == 2) {
			return Math.max(nums[0], nums[1]);
		}
		int[] dp = new int[nums.length];
		dp[0] = nums[0];
		dp[1] = Math.max(nums[0], nums[1]);
		for (int i = 2; i < nums.length; i++) {
			dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);
		}
		return dp[dp.length - 1];
	}
}
```

## 746.使用最小花费爬楼梯

:black_nib:解题思路：

1. DP
   $$
   dp[i] = cost[i] + min(dp[i-1],dp[i-2])
   $$
   

```java
//1
class Solution {
	public int minCostClimbingStairs(int[] cost) {
		int first = 0;
		int second = 0;
		int cur = 0;
		for (int i = 0; i < cost.length; i++) {
			cur = cost[i] + Math.min(first, second);
			first = second;
			second = cur;
		}
		return Math.min(first, second);
	}
}
//2
class Solution {
	public int minCostClimbingStairs(int[] cost) {
		if (cost.length == 0) {
			return 0;
		}
		if (cost.length == 1) {
			return cost[0];
		}
		int[] dp = new int[cost.length + 1];
		dp[0] = cost[0];
		dp[1] = cost[1];
		for (int i = 2; i < cost.length; i++) {
			dp[i] = cost[i] + Math.min(dp[i - 1], dp[i - 2]);
		}
		dp[cost.length] = Math.min(dp[cost.length - 1], dp[cost.length - 2]);
		return dp[cost.length];
	}
}
```
